package main

// Паттерн «Адаптер»

// Реализовать паттерн проектирования «Адаптер» на любом примере.

// Описание: паттерн Adapter позволяет сконвертировать интерфейс
// одного класса в интерфейс другого, который ожидает клиент.

// Продемонстрируйте на простом примере в Go: у вас есть существующий
// интерфейс (или структура) и другой,
// несовместимый по интерфейсу потребитель — напишите адаптер,
// который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.

// Поясните применимость паттерна, его плюсы и минусы,
// а также приведите реальные примеры использования.

///////////////////////////////////////////////////////////////////////////////////
// +++
// паттерн адаптер нужен, чтобы использовать готовый интрейфейс,
// который чуть не соответствует требовоемой структуре, и чтобы не менять старый интерфейс, мы как бы
// адаптируем его под нашу структуру, в этом и плюс адаптера, что мы не будем плодить много лишнего мусора в коде

// ---
// из минусов что я заметил, чуть сложно по пониманию кодовой базы, когда много адаптеров
// и не сразу понятно что к чему

// Источники:
// https://www.youtube.com/watch?v=o9sCFOv-uKE
// https://www.youtube.com/watch?v=6xDBbYe11HQ
///////////////////////////////////////////////////////////////////////////////////

type Figure interface {
	GetArea()
}

type Squat struct {
}

func (s *Squat) GetArea() {
}

type SquatAdapter struct {
	squat *Squat
}

func (s *SquatAdapter) GetArea() {
	s.squat.GetArea()
}

func main() {
	var s SquatAdapter = SquatAdapter{squat: &Squat{}}
	s.squat.GetArea()
}
